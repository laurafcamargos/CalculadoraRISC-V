	.data
	.align 0
#Strings para interação com o usuário
div_by_zero_error:   .asciz "Erro: divisão por zero\n"
invalid_op_error:    .asciz "Erro: operação inválida\n"
int_error:	     .asciz "Erro: insira um número inteiro\n"
result_str:          .asciz "Resultado: "
newline:             .asciz "\n"
prompt_num:    	     .asciz "Digite um número: "
prompt_op:           .asciz "Digite a operação (+, -, *, /, u, f): "
undo_msg:            .asciz "Operação desfeita. Resultado anterior: "
	.align 2
atual:	.space 8
	.text
	.align 2
	.globl main
	
	#Estrutura de cada nó da lista
	#Offset | Tamanho | Conteúdo
	#0-3    | 4 bytes | Resultado da operação atual (inteiro)
	#4-7	| 4 bytes | Ponteiro para o endereço do próximo nó ou NULL(word)
	
	# s0 : resultado atual
	# s1 : endereço do nó atual
	#s11 : -1 (NULL)
	
main:
	# Inicialização de variável
	li s11, -1 # s11 = -1
	
	# Primeira operação
	jal ler_int
	mv s0, a0
	
	# s0 = resultado atual
	# s1 = endereço do nó atual
	# Cria primeiro nó da lista
	la s1, atual
	sw s0, 0(s1) # Resultado = primeiro número digitado
	sw s11, 4(s1) # Ponteiro de volta = NULL
	
	main_loop:
		jal ler_operador      # operador em a0
		mv t1, a0             # salva operador temporariamente

		jal ler_int           # segundo número em a0
		mv t2, a0             # salva segundo número
    
		mv a0, s0             # resultado anterior vira num1
		mv a1, t1             # operador
		mv a2, t2             # segundo número
    		
    		# Parâmetros: a0 = num1, a1 = operador, a2 = num2
		jal realizar_operacao # Retorno no a0
		
		mv a1, s1 # Passando o endereço do agora antigo nó
		
		# Parâmetros: a0 = valor a ser armazenado
		#             a1 = endereço do nó anterior
		jal armazenar_resultado 
		
		j main_loop

#-----------------------------------------------------------
# Função: armazenar_resultado
# Parâmetro: a0 = valor a ser armazenado
#            a1 = endereço do nó anterior
# Alterações:
#            s0 é o atual resultado
#            s1 agora tem o endereço do novo nó
#-----------------------------------------------------------
armazenar_resultado:
	addi sp, sp, -4        # Aloca espaço para ra
	sw ra, 0(sp)           # Salva endereço de retorno 
    	
    	# Preservando entradas
	mv t2, a0              # Preserva valor em t2
   	mv t3, a1              # Preserva endereço em t3
    
	###### Alocar memória ######
	li a0, 8 # a0 = 8
	addi a7, zero, 9
	ecall # aloca 8 bytes na heap
	# a0 é o novo endereço
    
	# Configura novo nó
	sw t2, 0(a0)           # Armazena valor no nó
	lw t4, 0(t3)           # Carrega atual nó anterior
	sw t4, 4(a0)           # Define próximo do novo nó
    
	# Atualiza lista
	sw a0, 0(t3)           # Atualiza ponteiro atual
    
	mv s0, t2              # s0 = valor armazenado
  	mv s1, a0              # s1 = endereço do novo nó
    
	lw ra, 0(sp)           # Restaura ra
	addi sp, sp, 4
	jr ra

#-----------------------------------------------------------
# Função: ler_int
# Retorna: a0 = valor lido
#-----------------------------------------------------------
ler_int:
	li a7, 4
	la a0, prompt_num # "Digite um número: "
	ecall
    
	li a7, 5          # Read int
	ecall             # Retorno em a0
    
	jr ra             # Retorno

#-----------------------------------------------------------
# Função: ler_operador
# Retorna: a0 = operador lido
#-----------------------------------------------------------
ler_operador:
	li a7, 4
	la a0, prompt_op  # "Digite a operação (+, -, *, /, u, f): "
	ecall

	li a7, 12         # Read Char
	ecall             # Retorno em a0

	jr ra

#-----------------------------------------------------------
# Função: realizar_operacao
# Parâmetros: a0 = num1, a1 = operador, a2 = num2
# Retorna: a1 = resultado
#-----------------------------------------------------------
realizar_operacao:

	li t0, 43          # t0 = '+'
	beq a1, t0, op_add
    
	li t0, 45          # t0 = '-'
	beq a1, t0, op_sub
    
	li t0, 42          # t0 = '*'
	beq a1, t0, op_mul
    
	li t0, 47          # t0 = '/'
	beq a1, t0, op_div
    
	li t0, 117         # t0 = 'u'
	beq a1, t0, undo
    
	li t0, 102         # 'f'
	beq a1, t0, fim_programa
	
	j op_invalida # Operação inválida (default)

op_invalida:
	la a0, invalid_op_error # "Erro: operação inválida\n"
	li a7, 4           # Print string
	ecall

# Parâmetros: a0 = num1, a2 = num2
op_add:
	add a0, a0, a2
	j fim_operacao
op_sub:
	sub a0, a0, a2
	j fim_operacao
op_mul:
	mul a0, a0, a2
	j fim_operacao
op_div:
	beqz a2, erro_div_zero
	div a0, a0, a2
	j fim_operacao

erro_div_zero:
	la a0, div_by_zero_error # "Erro: divisão por zero\n"
	li a7, 4           # Print string
  	ecall
  	
  	j fim_programa
	
fim_operacao:
	add t1, zero, a0
	la a0, result_str  # "Resultado: "
	li a7, 4           # Print string
	ecall
	
	add a0, zero, t1
	li a7, 1           # Print int
	ecall
	
	la a0, newline     # "\n"
	li a7, 4           # Print string
	ecall
    
	add a0,zero,t1
    
fim_programa:
 	li a7,10
 	ecall

#-----------------------------------------------------------
# Função: undo (implementação básica)
#-----------------------------------------------------------
undo:
    addi sp, sp, -8
    sw ra, 0(sp)

    lw t0, atual          # t0 = endereço do nó atual
    beqz t0, fim_undo     # Se atual for 0, não há nada

    lw t1, 4(t0)          # t1 = endereço do nó anterior
    li t2, -1
    beq t1, t2, fim_undo  # Se for NULL, não há operação anterior

    lw a3, 0(t1)          # Atualiza a3 com resultado anterior
    la t0, atual
    sw t1, 0(t0)          # atual = anterior

    # Imprime mensagem
    li a7, 4
    la a0, undo_msg
    ecall

    li a7, 1
    mv a0, a3
    ecall

    li a7, 4
    la a0, newline
    ecall

fim_undo:
    lw ra, 0(sp)
    addi sp, sp, 8
    jr ra