	.data
	.align 0
#Strings para auxiliar a entender o programa
div_by_zero_error:   .asciz "Erro: divisão por zero\n"
invalid_op_error:    .asciz "Erro: operação inválida\n"
int_error:	     .asciz "Erro: insira um número inteiro\n"
result_str:          .asciz "Resultado: "
newline:             .asciz "\n"
prompt_num:    	     .asciz "Digite um número: "
prompt_op:           .asciz "Digite a operação (+, -, *, /, u, f): "
undo_msg:            .asciz "Operação desfeita. Resultado anterior: "
	.align 2
#head:	.word # ponteiro para o primeiro no da lista
atual:	.word
	.text
	.align 2	#instruções de 32 bits
	.globl main
	
	#Estrutura de cada nó da lista
	#Offset | Tamanho | Conteúdo
	#0-3    | 4 bytes | Resultado da operação atual (inteiro)
	#4-7	| 4 bytes | Ponteiro para o endereço do próximo nó ou NULL(word)
	
	#Estretégia para registradores:
	#a0 - parâmetro/retorno da ecall
	#a1 - parâmetro das funções
	
	#a3 - salva o resultado atual da operação
	#a4 - endereço do nó alocado pela função alocar_no
	#a5 - endereço recém alocado
	
	#a7 - parâmetro do ecall
	#s0 - tamanho de um nó (8 bytes)
	#s1 - tamanho atual da lista (muda)
	#s2 - quantidade total de nos da lista (constante)
	#s10 - Valor NULL (-1) usado para alocal novo nó
main:

	# Inicializando variaveis:
	addi s0, zero, 8 # tamanho do nó em bytes
        #addi s1, zero, 0 #tamanho atual da lista
	addi s10, zero, -1 #valor de ponteiro nulo
    	
    	# Inicialização da lista
    	la a4, atual 	  #a4 = &atual
	sw zero, 0(a4)   # resultado = 0 , atual.resultado = 0
	sw s10, 4(a4)    # ponteiro pro anterior = NULL (-1), atual.prox = NULL


   	# Primeira operação (num1 op num2)
    	jal primeira_operacao
    	mv a3, a0  # o resultado da operação está em a0
    	jal armazenar_resultado

main_loop:
    jal ler_operador     # operador em a1
    mv t0, a1            # salva operador temporariamente
    
    jal ler_int          # segundo número em a0
    mv t1, a0            # salva segundo número
    
    mv a0, a3            # resultado anterior vira num1
    mv a1, t0            # operador
    mv a2, t1            # segundo número
    
    jal realizar_operacao
    
    mv a3, a0           # resultado vai pra a3
    jal armazenar_resultado

    j main_loop



#-----------------------------------------------------------
# Função: armazenar_resultado (Implementação Corrigida)
# Parâmetros: a0 = valor a ser armazenado
#-----------------------------------------------------------
armazenar_resultado:
    addi sp, sp, -12       # Aloca espaço na pilha
    sw ra, 0(sp)           # Salva endereço de retorno
    sw a0, 4(sp)           # Salva valor do resultado
    sw a4, 8(sp)           # Salva a4 (endereço de 'atual')

    # Alocar novo nó (8 bytes)
    li a7, 9               # Código sbrk
    li a0, 8               # 8 bytes (4 para valor, 4 para próximo)
    ecall                  # a0 = endereço do novo nó

    # Preencher novo nó
    lw t0, 4(sp)           # Recupera valor do resultado
    sw t0, 0(a0)           # Armazena resultado no nó

    # Ligar novo nó à lista
    lw a4, 8(sp)           # Recupera a4 = endereço de 'atual'
    lw t1, 0(a4)           # t1 = valor atual de 'atual' (nó anterior)
    sw t1, 4(a0)           # Define próximo do novo nó como antigo 'atual'

    # Atualizar 'atual' para novo nó
    sw a0, 0(a4)           # Atualiza variável 'atual' na memória


    lw ra, 0(sp)           # Restaura registradores
    lw a4, 8(sp)
    addi sp, sp, 12
    jr ra
#-----------------------------------------------------------
# Função: primeira_operacao
# Lê dois números e uma operação inicial
#-----------------------------------------------------------
criar_lista:
	addi sp, sp, -4
	sw ra, 0(sp)
	jal inserir_no
	
	lw ra, 0(sp)
	addi sp, sp, 4
	jr ra

inserir_no:
	###### Alocar memória ######
	add a0, zero, s0 # s0 = 8
	addi a7, zero, 9
	ecall # aloca 8bytes na heap
	
	# Salvando em a5 o endereco do no recem alocado
	add a5, zero, a0
	
	###### Preencher novo nó ######
	sw a3, 0(a5)
	# Fazendo ponteiro do atual apontar pro endereço do nó anterior
	lw t1, 0(a4)        # t1 = endereço do nó atual anterior
    	sw t1, 4(a5)        # Define próximo como o nó anterior
	sw a5, 0(a4)        # atual = novo nó
	
	jr ra


primeira_operacao:
    addi sp, sp, -12  #pilha vai armazenar dados temporarios
    sw ra, 0(sp)      #preserva o endereço de retorno para uso futuro.
    
    jal ler_int       # Primeiro número em a0
    mv s1, a0         # Salva em s1
    
    jal ler_operador  # Operador em a0
    mv s2, a0         # Salva em s2
    
    jal ler_int       # Segundo número em a0
    mv s3, a0         # Salva em s3
    
    # Realiza operação
    mv a0, s1
    mv a1, s2
    mv a2, s3
    jal realizar_operacao
    
    # Armazena resultado na lista
    #jal armazenar_resultado
    
    lw ra, 0(sp)
    addi sp, sp, 12
    ret

#-----------------------------------------------------------
# Função: ler_int
# Retorna: a1 = valor lido
#-----------------------------------------------------------
ler_int:
    addi sp, sp, -8
    sw ra, 0(sp)
    
    li a7, 4
    la a0, prompt_num
    ecall
    
    li a7, 5
    ecall
	

    lw ra, 0(sp)
    addi sp, sp, 8
    jr ra

#-----------------------------------------------------------
# Função: ler_operador
# Retorna: a1 = operador lido
#-----------------------------------------------------------
ler_operador:
    addi sp, sp, -8
    sw ra, 0(sp)
    
    li a7, 4
    la a0, prompt_op
    ecall
    
    li a7, 12
    ecall
    
    add a1,zero,a0
    lw ra, 0(sp)
    addi sp, sp, 8
    jr ra
#-----------------------------------------------------------
# Função: realizar_operacao
# Parâmetros: a0 = num1, a1 = operador, a2 = num2
# Retorna: a1 = resultado
#-----------------------------------------------------------
realizar_operacao:
    addi sp, sp, -16
    sw ra, 0(sp)
    #sw s1, 4(sp)
    
    li t0, '+'
    beq a1, t0, op_add
    li t0, '-'
    beq a1, t0, op_sub
    li t0, '*'
    beq a1, t0, op_mul
    li t0, '/'
    beq a1, t0, op_div
    li t0, 'u'         # Adicione esta linha
    beq a1, t0, undo   # Adicione esta linha
    li t0, 'f'	
    beq a1, t0, fim_programa #se o retorno(a1) do ler_operador for 'f' -> sai do programa
    # Operação inválida
    j op_invalida
    j fim_operacao
op_invalida:
    la a0, invalid_op_error
    li a7, 4
    ecall
    lw ra, 0(sp)
    addi sp, sp, 16
    jr ra
op_add:
    add a0, a0, a2
    j fim_operacao

op_sub:
    sub a0, a0, a2
    j fim_operacao

op_mul:
    mul a0, a0, a2
    j fim_operacao

op_div:
    beqz a2, erro_div_zero
    div a0, a0, a2
    j fim_operacao

erro_div_zero:
    la a0, div_by_zero_error
    li a7, 4
    ecall
    lw ra, 0(sp)
    addi sp, sp, 16
    jr ra
fim_operacao:
   add t1,zero,a0
   la a0,result_str
    li a7,4
    ecall
    add a0,zero,t1
    li a7, 1
    ecall
	
    la a0,newline
    li a7,4
    ecall
    
    add a0,zero,t1
    lw ra, 0(sp)
    addi sp, sp, 16
    jr ra
    
fim_programa:
 	li a7,10
 	ecall

#-----------------------------------------------------------
# Função: undo (implementação básica)
#-----------------------------------------------------------
undo:
    addi sp, sp, -8
    sw ra, 0(sp)
    
    lw t0, atual
    beqz t0, fim_undo
    
    # Pega o nó anterior
    lw t1, 4(t0)
    la t0,atual
    sw a0, 0(t0)
    
    # Imprime valor anterior
    li a7, 4
    la a0, undo_msg
    ecall
    
    li a7, 1
    lw a0, 0(t1)
    ecall
    
    li a7, 4
    la a0, newline
    ecall
	
fim_undo:
    lw ra, 0(sp)
    addi sp, sp, 8
    jr ra
